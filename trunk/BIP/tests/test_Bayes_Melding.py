import unittest

class TestMeld(unittest.TestCase):
    def test___init__(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        assert False # TODO: implement your test here

    def test_abcRun(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.abcRun(fitfun, data, t, savetemp))
        assert False # TODO: implement your test here

    def test_addData(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.add_data(data, model, limits, l, **kwargs))
        assert False # TODO: implement your test here

    def test_basicfit(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.basicfit(s1, s2))
        assert False # TODO: implement your test here

    def test_filtM(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.filtM(cond, x, limits))
        assert False # TODO: implement your test here

    def test_getPosteriors(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.getPosteriors(t))
        assert False # TODO: implement your test here

    def test_logPooling(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.logPooling(phi))
        assert False # TODO: implement your test here

    def test_run(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.run(*args))
        assert False # TODO: implement your test here

    def test_runModel(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.runModel(savetemp, t))
        assert False # TODO: implement your test here

    def test_setPhi(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.setPhi(names, dists, pars, limits))
        assert False # TODO: implement your test here

    def test_setPhiFromData(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.setPhiFromData(names, data, limits))
        assert False # TODO: implement your test here

    def test_setTheta(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.setTheta(names, dists, pars))
        assert False # TODO: implement your test here

    def test_setThetaFromData(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.setThetaFromData(names, data, limits))
        assert False # TODO: implement your test here

    def test_sir(self):
        # meld = Meld(K, L, model, ntheta, nphi, alpha, verbose, viz)
        # self.assertEqual(expected, meld.sir(data, t, tau, nopool, savetemp))
        assert False # TODO: implement your test here

class TestEnumRun(unittest.TestCase):
    def test_enum_run(self):
        # self.assertEqual(expected, enumRun(model, theta, k))
        assert False # TODO: implement your test here

class TestModel(unittest.TestCase):
    def test_model(self):
        # self.assertEqual(expected, model(r, p0, n))
        assert False # TODO: implement your test here

class TestPlotRaHist(unittest.TestCase):
    def test_plot_ra_hist(self):
        # self.assertEqual(expected, plotRaHist(arr))
        assert False # TODO: implement your test here

class TestMain2(unittest.TestCase):
    def test_main2(self):
        # self.assertEqual(expected, main2())
        assert False # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()
